# The name of this workflow. This name appears in the GitHub Actions UI.
name: Basic CI Pipeline

# The 'on' section tells GitHub when to trigger this workflow.
on:
  # This workflow will be triggered by a push event...
  push:
    # ...but only when the push is to the 'main' branch.
    branches:
      - main

# The 'jobs' section defines one or more jobs that will run as part of this workflow.
jobs:
  # Define a job called 'build-and-test' that runs all our build and test steps.
  build-and-test:
    # 'runs-on' specifies the type of machine/runner to use, here the latest Ubuntu.
    runs-on: ubuntu-latest

    # 'steps' is a list of the sequential commands or actions that will be executed.
    steps:
      # Step 1: Checkout code from the repository.
      - name: Checkout code
        # Uses the official GitHub Action to check out the source code.
        uses: actions/checkout@v4

      # Step 2: Set up the Python environment.
      - name: Set up Python
        # Uses GitHub's official action for setting up Python.
        uses: actions/setup-python@v5
        with:
          # 'python-version' defines which version of Python to use for this job.
          python-version: '3.11'

      # Step 3: Install project dependencies.
      - name: Install dependencies
        # The 'run' command lets you execute shell commands.
        run: |
          # Here we install all required Python packages from requirements.txt.
          pip install -r requirements.txt

      # Step 4: Build the application.
      - name: Build application
        run: |
          # This is a placeholder build command.
          # It simulates a build by creating a directory for build artifacts.
          echo "Building the app..."
          mkdir build-output
          # Create a dummy file inside the build-output directory.
          echo "Build artifact content" > build-output/artifact.txt

      # Step 5: Run Unit Tests.
      - name: Run Unit Tests
        # Here we run unit tests located in the 'tests/unit' folder.
        run: pytest tests/unit

      # Step 6: Run Integration Tests.
      - name: Run Integration Tests
        # Here we run integration tests located in the 'tests/integration' folder.
        run: pytest tests/integration

      # Step 7: Run Functional Tests.
      - name: Run Functional Tests
        # Run tests that check application features in 'tests/functional'.
        run: pytest tests/functional

      # Step 8: Run Regression Tests.
      - name: Run Regression Tests
        # Run regression tests from the 'tests/regression' folder.
        run: pytest tests/regression

      # Step 9: Upload test results.
      - name: Upload test results
        # This uses the official upload artifact action to store the test results.
        uses: actions/upload-artifact@v4
        with:
          # 'name' gives the artifact a label in the GitHub Actions UI.
          name: test-results
          # 'path' specifies the file or directory to upload.
          # Here it is set to the current directory, adjust if results are stored elsewhere.
          path: .

  # Define a separate job for deployment to the staging environment.
  deploy-to-staging:
    # 'needs' indicates this job will only run after 'build-and-test' completes successfully.
    needs: build-and-test
    # Again, use GitHub's Ubuntu runner for this job.
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout code again in this separate job.
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Simulate deployment to staging.
      - name: Simulate deployment to staging
        # Here we simply run a command to simulate deployment.
        # In a real pipeline, you would run your deployment commands or scripts.
        run: echo "Deploying to staging environment..."
